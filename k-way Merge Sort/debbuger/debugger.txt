num_ways = 3
runs_size = 3
Arquivo Gerado simulando Memoria external(Disco Rigido)
5
5
8
6
1
5
5
1
1
Entrando na funcao External Sort
Entrando na funcao createInitialRuns
Lendo Arquivo criado (Disco Rigido)
Criando Vetor de tamanho 3, representa runs
Nomeando as runs (Buffers na Memoria) [0]
Nomeando as runs (Buffers na Memoria) [1]
Nomeando as runs (Buffers na Memoria) [2]

Entrando no while ate more_input = false


more_input_atual = true

i = 0
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 5, 7209152, 1983729984 }

i = 1
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 5, 5, 1983729984 }

i = 2
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 5, 5, 8 }

Entrando no MergeSort
Parametros : arr, left = 0, right = 2


.........................................


Nova Pilha
arr = { 5, 5, 8 }
0 < 2 ?
Calculando o meio left = 0, right = 2, meio = 0 + 2 / 2 = 1
Entrando Primeiro Merge
left = 0
right = 2
middle = 1
Parametros: arr, left, middle


.........................................


Nova Pilha
arr = { 5, 5, 8 }
0 < 1 ?
Calculando o meio left = 0, right = 1, meio = 0 + 1 / 2 = 0
Entrando Primeiro Merge
left = 0
right = 1
middle = 0
Parametros: arr, left, middle


.........................................


Nova Pilha
arr = { 5, 5, 8 }
0 < 0 ?
NAO ENTROU EM NENHUM MERGE, POIS 0 >= 0


.........................................


Pilha Anterior!
Entrando Segundo Merge
left = 0
right = 1
middle = 0
Parametros: arr, middle + 1, right


.........................................


Nova Pilha
arr = { 5, 5, 8 }
1 < 1 ?
NAO ENTROU EM NENHUM MERGE, POIS 1 >= 1


.........................................


Pilha Anterior!
Entrando no Merge
left = 0
right = 1
middle = 0


.........................................


Nova Pilha - Funcao Merge
left: 0
right: 1
middle: 0
N1: 1
N2: 1
Tamanho de do vetor L = 1, R = 1
L[0] = 5
R[0] = 5
i: 0 (incide do vetor left)
j: 0 (indice do vetor right)
k: 0 (indice do vetor final)
Entrando no while ate i >= n1 ou j >= n2
i: 0
j: 0
k: 0
0 < 1  && 0 < 1 ?
Se L[i] <= R[j]; 5 <= 5 ?
Entao arr[k] = L[i]; arr[0] = 5
Passando Valores restantes se houver algum
j < n2; 0 < 1
j: 0
k: 1
arr[k] = R[j]; arr[1] = 5

arr = { 5, 5, 8 }
Fim do Merge

Entrando Segundo Merge
left = 0
right = 2
middle = 1
Parametros: arr, middle + 1, right


.........................................


Nova Pilha
arr = { 5, 5, 8 }
2 < 2 ?
NAO ENTROU EM NENHUM MERGE, POIS 2 >= 2


.........................................


Pilha Anterior!
Entrando no Merge
left = 0
right = 2
middle = 1


.........................................


Nova Pilha - Funcao Merge
left: 0
right: 2
middle: 1
N1: 2
N2: 1
Tamanho de do vetor L = 2, R = 1
L[0] = 5
L[1] = 5
R[0] = 8
i: 0 (incide do vetor left)
j: 0 (indice do vetor right)
k: 0 (indice do vetor final)
Entrando no while ate i >= n1 ou j >= n2
i: 0
j: 0
k: 0
0 < 2  && 0 < 1 ?
Se L[i] <= R[j]; 5 <= 8 ?
Entao arr[k] = L[i]; arr[0] = 5
i: 1
j: 0
k: 1
1 < 2  && 0 < 1 ?
Se L[i] <= R[j]; 5 <= 8 ?
Entao arr[k] = L[i]; arr[1] = 5
Passando Valores restantes se houver algum
j < n2; 0 < 1
j: 0
k: 2
arr[k] = R[j]; arr[2] = 8

arr = { 5, 5, 8 }
Fim do Merge



Saiu do MergeSort
Vetor atual
next_output_file: 0
Escrevendo nas runs (Buffers da memoria)
j: 0
i: 3
Elemento passado: 5
j: 1
i: 3
Elemento passado: 5
j: 2
i: 3
Elemento passado: 8


more_input_atual = true

i = 0
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 6, 5, 8 }

i = 1
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 6, 1, 8 }

i = 2
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 6, 1, 5 }

Entrando no MergeSort
Parametros : arr, left = 0, right = 2


.........................................


Nova Pilha
arr = { 6, 1, 5 }
0 < 2 ?
Calculando o meio left = 0, right = 2, meio = 0 + 2 / 2 = 1
Entrando Primeiro Merge
left = 0
right = 2
middle = 1
Parametros: arr, left, middle


.........................................


Nova Pilha
arr = { 6, 1, 5 }
0 < 1 ?
Calculando o meio left = 0, right = 1, meio = 0 + 1 / 2 = 0
Entrando Primeiro Merge
left = 0
right = 1
middle = 0
Parametros: arr, left, middle


.........................................


Nova Pilha
arr = { 6, 1, 5 }
0 < 0 ?
NAO ENTROU EM NENHUM MERGE, POIS 0 >= 0


.........................................


Pilha Anterior!
Entrando Segundo Merge
left = 0
right = 1
middle = 0
Parametros: arr, middle + 1, right


.........................................


Nova Pilha
arr = { 6, 1, 5 }
1 < 1 ?
NAO ENTROU EM NENHUM MERGE, POIS 1 >= 1


.........................................


Pilha Anterior!
Entrando no Merge
left = 0
right = 1
middle = 0


.........................................


Nova Pilha - Funcao Merge
left: 0
right: 1
middle: 0
N1: 1
N2: 1
Tamanho de do vetor L = 1, R = 1
L[0] = 6
R[0] = 1
i: 0 (incide do vetor left)
j: 0 (indice do vetor right)
k: 0 (indice do vetor final)
Entrando no while ate i >= n1 ou j >= n2
i: 0
j: 0
k: 0
0 < 1  && 0 < 1 ?
Se L[i] <= R[j]; 6 <= 1 ?
Entao arr[k] = R[j]; arr[0] = 1
Passando Valores restantes se houver algum
i < n1; 0 < 1
i: 0
k: 1
arr[k] = L[i]; arr[1] = 6

arr = { 1, 6, 5 }
Fim do Merge

Entrando Segundo Merge
left = 0
right = 2
middle = 1
Parametros: arr, middle + 1, right


.........................................


Nova Pilha
arr = { 1, 6, 5 }
2 < 2 ?
NAO ENTROU EM NENHUM MERGE, POIS 2 >= 2


.........................................


Pilha Anterior!
Entrando no Merge
left = 0
right = 2
middle = 1


.........................................


Nova Pilha - Funcao Merge
left: 0
right: 2
middle: 1
N1: 2
N2: 1
Tamanho de do vetor L = 2, R = 1
L[0] = 1
L[1] = 6
R[0] = 5
i: 0 (incide do vetor left)
j: 0 (indice do vetor right)
k: 0 (indice do vetor final)
Entrando no while ate i >= n1 ou j >= n2
i: 0
j: 0
k: 0
0 < 2  && 0 < 1 ?
Se L[i] <= R[j]; 1 <= 5 ?
Entao arr[k] = L[i]; arr[0] = 1
i: 1
j: 0
k: 1
1 < 2  && 0 < 1 ?
Se L[i] <= R[j]; 6 <= 5 ?
Entao arr[k] = R[j]; arr[1] = 5
Passando Valores restantes se houver algum
i < n1; 1 < 2
i: 1
k: 2
arr[k] = L[i]; arr[2] = 6

arr = { 1, 5, 6 }
Fim do Merge



Saiu do MergeSort
Vetor atual
next_output_file: 1
Escrevendo nas runs (Buffers da memoria)
j: 0
i: 3
Elemento passado: 1
j: 1
i: 3
Elemento passado: 5
j: 2
i: 3
Elemento passado: 6


more_input_atual = true

i = 0
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 5, 5, 6 }

i = 1
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 5, 1, 6 }

i = 2
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
arr = { 5, 1, 1 }

Entrando no MergeSort
Parametros : arr, left = 0, right = 2


.........................................


Nova Pilha
arr = { 5, 1, 1 }
0 < 2 ?
Calculando o meio left = 0, right = 2, meio = 0 + 2 / 2 = 1
Entrando Primeiro Merge
left = 0
right = 2
middle = 1
Parametros: arr, left, middle


.........................................


Nova Pilha
arr = { 5, 1, 1 }
0 < 1 ?
Calculando o meio left = 0, right = 1, meio = 0 + 1 / 2 = 0
Entrando Primeiro Merge
left = 0
right = 1
middle = 0
Parametros: arr, left, middle


.........................................


Nova Pilha
arr = { 5, 1, 1 }
0 < 0 ?
NAO ENTROU EM NENHUM MERGE, POIS 0 >= 0


.........................................


Pilha Anterior!
Entrando Segundo Merge
left = 0
right = 1
middle = 0
Parametros: arr, middle + 1, right


.........................................


Nova Pilha
arr = { 5, 1, 1 }
1 < 1 ?
NAO ENTROU EM NENHUM MERGE, POIS 1 >= 1


.........................................


Pilha Anterior!
Entrando no Merge
left = 0
right = 1
middle = 0


.........................................


Nova Pilha - Funcao Merge
left: 0
right: 1
middle: 0
N1: 1
N2: 1
Tamanho de do vetor L = 1, R = 1
L[0] = 5
R[0] = 1
i: 0 (incide do vetor left)
j: 0 (indice do vetor right)
k: 0 (indice do vetor final)
Entrando no while ate i >= n1 ou j >= n2
i: 0
j: 0
k: 0
0 < 1  && 0 < 1 ?
Se L[i] <= R[j]; 5 <= 1 ? 
Entao arr[k] = R[j]; arr[0] = 1
Passando Valores restantes se houver algum
i < n1; 0 < 1
i: 0
k: 1
arr[k] = L[i]; arr[1] = 5

arr = { 1, 5, 1 }
Fim do Merge

Entrando Segundo Merge
left = 0
right = 2
middle = 1
Parametros: arr, middle + 1, right


.........................................


Nova Pilha
arr = { 1, 5, 1 }
2 < 2 ?
NAO ENTROU EM NENHUM MERGE, POIS 2 >= 2


.........................................


Pilha Anterior!
Entrando no Merge
left = 0
right = 2
middle = 1


.........................................


Nova Pilha - Funcao Merge
left: 0
right: 2
middle: 1
N1: 2
N2: 1
Tamanho de do vetor L = 2, R = 1
L[0] = 1
L[1] = 5
R[0] = 1
i: 0 (incide do vetor left)
j: 0 (indice do vetor right)
k: 0 (indice do vetor final)
Entrando no while ate i >= n1 ou j >= n2
i: 0
j: 0
k: 0
0 < 2  && 0 < 1 ?
Se L[i] <= R[j]; 1 <= 1 ?
Entao arr[k] = L[i]; arr[0] = 1
i: 1
j: 0
k: 1
1 < 2  && 0 < 1 ?
Se L[i] <= R[j]; 5 <= 1 ?
Entao arr[k] = R[j]; arr[1] = 1
Passando Valores restantes se houver algum
i < n1; 1 < 2
i: 1
k: 2
arr[k] = L[i]; arr[2] = 5

arr = { 1, 1, 5 }
Fim do Merge



Saiu do MergeSort
Vetor atual
next_output_file: 2
Escrevendo nas runs (Buffers da memoria)
j: 0
i: 3
Elemento passado: 1
j: 1
i: 3
Elemento passado: 1
j: 2
i: 3
Elemento passado: 5


more_input_atual = true

i = 0
run_size = 3
Lendo as 3 primeiras posicoes do arquivo in e armazenando-as no array
Entrou na condicao i = 0, arr[i] = 1, more_input = false, ou seja foi um arquivo ja lido do ultimo conjunto

Entrando no MergeSort
Parametros : arr, left = 0, right = -1


.........................................


Nova Pilha
arr = { 1, 1, 5 }
0 < -1 ?
NAO ENTROU EM NENHUM MERGE, POIS 0 >= -1


.........................................


Pilha Anterior!


Saiu do MergeSort
Vetor atual
next_output_file: 3
Escrevendo nas runs (Buffers da memoria)


Entrando no MergeFiles!